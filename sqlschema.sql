-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS auth.audit_log_entries
(
    instance_id uuid,
    id uuid NOT NULL,
    payload json,
    created_at timestamp with time zone,
    ip_address character varying(64) COLLATE pg_catalog."default" NOT NULL DEFAULT ''::character varying,
    CONSTRAINT audit_log_entries_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.audit_log_entries
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.audit_log_entries
    IS 'Auth: Audit trail for user actions.';

CREATE TABLE IF NOT EXISTS auth.flow_state
(
    id uuid NOT NULL,
    user_id uuid,
    auth_code text COLLATE pg_catalog."default" NOT NULL,
    code_challenge_method auth.code_challenge_method NOT NULL,
    code_challenge text COLLATE pg_catalog."default" NOT NULL,
    provider_type text COLLATE pg_catalog."default" NOT NULL,
    provider_access_token text COLLATE pg_catalog."default",
    provider_refresh_token text COLLATE pg_catalog."default",
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    authentication_method text COLLATE pg_catalog."default" NOT NULL,
    auth_code_issued_at timestamp with time zone,
    CONSTRAINT flow_state_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.flow_state
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.flow_state
    IS 'stores metadata for pkce logins';

CREATE TABLE IF NOT EXISTS auth.identities
(
    provider_id text COLLATE pg_catalog."default" NOT NULL,
    user_id uuid NOT NULL,
    identity_data jsonb NOT NULL,
    provider text COLLATE pg_catalog."default" NOT NULL,
    last_sign_in_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    email text COLLATE pg_catalog."default" GENERATED ALWAYS AS (lower((identity_data ->> 'email'::text))) STORED,
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    CONSTRAINT identities_pkey PRIMARY KEY (id),
    CONSTRAINT identities_provider_id_provider_unique UNIQUE (provider_id, provider)
);

ALTER TABLE IF EXISTS auth.identities
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.identities
    IS 'Auth: Stores identities associated to a user.';

COMMENT ON COLUMN auth.identities.email
    IS 'Auth: Email is a generated column that references the optional email property in the identity_data';

CREATE TABLE IF NOT EXISTS auth.instances
(
    id uuid NOT NULL,
    uuid uuid,
    raw_base_config text COLLATE pg_catalog."default",
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT instances_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.instances
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.instances
    IS 'Auth: Manages users across multiple sites.';

CREATE TABLE IF NOT EXISTS auth.mfa_amr_claims
(
    session_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    authentication_method text COLLATE pg_catalog."default" NOT NULL,
    id uuid NOT NULL,
    CONSTRAINT amr_id_pk PRIMARY KEY (id),
    CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey UNIQUE (session_id, authentication_method)
);

ALTER TABLE IF EXISTS auth.mfa_amr_claims
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.mfa_amr_claims
    IS 'auth: stores authenticator method reference claims for multi factor authentication';

CREATE TABLE IF NOT EXISTS auth.mfa_challenges
(
    id uuid NOT NULL,
    factor_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    verified_at timestamp with time zone,
    ip_address inet NOT NULL,
    otp_code text COLLATE pg_catalog."default",
    web_authn_session_data jsonb,
    CONSTRAINT mfa_challenges_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.mfa_challenges
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.mfa_challenges
    IS 'auth: stores metadata about challenge requests made';

CREATE TABLE IF NOT EXISTS auth.mfa_factors
(
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    friendly_name text COLLATE pg_catalog."default",
    factor_type auth.factor_type NOT NULL,
    status auth.factor_status NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    secret text COLLATE pg_catalog."default",
    phone text COLLATE pg_catalog."default",
    last_challenged_at timestamp with time zone,
    web_authn_credential jsonb,
    web_authn_aaguid uuid,
    CONSTRAINT mfa_factors_pkey PRIMARY KEY (id),
    CONSTRAINT mfa_factors_last_challenged_at_key UNIQUE (last_challenged_at)
);

ALTER TABLE IF EXISTS auth.mfa_factors
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.mfa_factors
    IS 'auth: stores metadata about factors';

CREATE TABLE IF NOT EXISTS auth.one_time_tokens
(
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token_type auth.one_time_token_type NOT NULL,
    token_hash text COLLATE pg_catalog."default" NOT NULL,
    relates_to text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    updated_at timestamp without time zone NOT NULL DEFAULT now(),
    CONSTRAINT one_time_tokens_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.one_time_tokens
    ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS auth.refresh_tokens
(
    instance_id uuid,
    id bigserial NOT NULL,
    token character varying(255) COLLATE pg_catalog."default",
    user_id character varying(255) COLLATE pg_catalog."default",
    revoked boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    parent character varying(255) COLLATE pg_catalog."default",
    session_id uuid,
    CONSTRAINT refresh_tokens_pkey PRIMARY KEY (id),
    CONSTRAINT refresh_tokens_token_unique UNIQUE (token)
);

ALTER TABLE IF EXISTS auth.refresh_tokens
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.refresh_tokens
    IS 'Auth: Store of tokens used to refresh JWT tokens once they expire.';

CREATE TABLE IF NOT EXISTS auth.saml_providers
(
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    entity_id text COLLATE pg_catalog."default" NOT NULL,
    metadata_xml text COLLATE pg_catalog."default" NOT NULL,
    metadata_url text COLLATE pg_catalog."default",
    attribute_mapping jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    name_id_format text COLLATE pg_catalog."default",
    CONSTRAINT saml_providers_pkey PRIMARY KEY (id),
    CONSTRAINT saml_providers_entity_id_key UNIQUE (entity_id)
);

ALTER TABLE IF EXISTS auth.saml_providers
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.saml_providers
    IS 'Auth: Manages SAML Identity Provider connections.';

CREATE TABLE IF NOT EXISTS auth.saml_relay_states
(
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    request_id text COLLATE pg_catalog."default" NOT NULL,
    for_email text COLLATE pg_catalog."default",
    redirect_to text COLLATE pg_catalog."default",
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    flow_state_id uuid,
    CONSTRAINT saml_relay_states_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.saml_relay_states
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.saml_relay_states
    IS 'Auth: Contains SAML Relay State information for each Service Provider initiated login.';

CREATE TABLE IF NOT EXISTS auth.schema_migrations
(
    version character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT schema_migrations_pkey PRIMARY KEY (version)
);

ALTER TABLE IF EXISTS auth.schema_migrations
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.schema_migrations
    IS 'Auth: Manages updates to the auth system.';

CREATE TABLE IF NOT EXISTS auth.sessions
(
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    factor_id uuid,
    aal auth.aal_level,
    not_after timestamp with time zone,
    refreshed_at timestamp without time zone,
    user_agent text COLLATE pg_catalog."default",
    ip inet,
    tag text COLLATE pg_catalog."default",
    CONSTRAINT sessions_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.sessions
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.sessions
    IS 'Auth: Stores session data associated to a user.';

COMMENT ON COLUMN auth.sessions.not_after
    IS 'Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.';

CREATE TABLE IF NOT EXISTS auth.sso_domains
(
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    domain text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT sso_domains_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.sso_domains
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.sso_domains
    IS 'Auth: Manages SSO email address domain mapping to an SSO Identity Provider.';

CREATE TABLE IF NOT EXISTS auth.sso_providers
(
    id uuid NOT NULL,
    resource_id text COLLATE pg_catalog."default",
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT sso_providers_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.sso_providers
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.sso_providers
    IS 'Auth: Manages SSO identity provider information; see saml_providers for SAML.';

COMMENT ON COLUMN auth.sso_providers.resource_id
    IS 'Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.';

CREATE TABLE IF NOT EXISTS auth.users
(
    instance_id uuid,
    id uuid NOT NULL,
    aud character varying(255) COLLATE pg_catalog."default",
    role character varying(255) COLLATE pg_catalog."default",
    email character varying(255) COLLATE pg_catalog."default",
    encrypted_password character varying(255) COLLATE pg_catalog."default",
    email_confirmed_at timestamp with time zone,
    invited_at timestamp with time zone,
    confirmation_token character varying(255) COLLATE pg_catalog."default",
    confirmation_sent_at timestamp with time zone,
    recovery_token character varying(255) COLLATE pg_catalog."default",
    recovery_sent_at timestamp with time zone,
    email_change_token_new character varying(255) COLLATE pg_catalog."default",
    email_change character varying(255) COLLATE pg_catalog."default",
    email_change_sent_at timestamp with time zone,
    last_sign_in_at timestamp with time zone,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    is_super_admin boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    phone text COLLATE pg_catalog."default" DEFAULT NULL::character varying,
    phone_confirmed_at timestamp with time zone,
    phone_change text COLLATE pg_catalog."default" DEFAULT ''::character varying,
    phone_change_token character varying(255) COLLATE pg_catalog."default" DEFAULT ''::character varying,
    phone_change_sent_at timestamp with time zone,
    confirmed_at timestamp with time zone GENERATED ALWAYS AS (LEAST(email_confirmed_at, phone_confirmed_at)) STORED,
    email_change_token_current character varying(255) COLLATE pg_catalog."default" DEFAULT ''::character varying,
    email_change_confirm_status smallint DEFAULT 0,
    banned_until timestamp with time zone,
    reauthentication_token character varying(255) COLLATE pg_catalog."default" DEFAULT ''::character varying,
    reauthentication_sent_at timestamp with time zone,
    is_sso_user boolean NOT NULL DEFAULT false,
    deleted_at timestamp with time zone,
    is_anonymous boolean NOT NULL DEFAULT false,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users_phone_key UNIQUE (phone)
);

ALTER TABLE IF EXISTS auth.users
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.users
    IS 'Auth: Stores user login data within a secure schema.';

COMMENT ON COLUMN auth.users.is_sso_user
    IS 'Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.';

CREATE TABLE IF NOT EXISTS public.advisors_consultants
(
    advisor_id serial NOT NULL,
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    email character varying(100) COLLATE pg_catalog."default" NOT NULL,
    specialization character varying(100) COLLATE pg_catalog."default",
    years_of_experience integer,
    rating double precision,
    consultation_fees numeric(10, 2),
    institution_id integer,
    availability json,
    profile_picture character varying(255) COLLATE pg_catalog."default",
    bio text COLLATE pg_catalog."default",
    languages text[] COLLATE pg_catalog."default",
    CONSTRAINT advisors_consultants_pkey PRIMARY KEY (advisor_id),
    CONSTRAINT advisors_consultants_email_key UNIQUE (email)
);

CREATE TABLE IF NOT EXISTS public.authentication_tokens
(
    token_id serial NOT NULL,
    user_id integer,
    token character varying(255) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    expires_at timestamp without time zone NOT NULL,
    is_valid boolean DEFAULT true,
    CONSTRAINT authentication_tokens_pkey PRIMARY KEY (token_id)
);

CREATE TABLE IF NOT EXISTS public.blog_comments
(
    comment_id serial NOT NULL,
    post_id integer,
    user_id integer,
    content text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT blog_comments_pkey PRIMARY KEY (comment_id)
);

CREATE TABLE IF NOT EXISTS public.blog_posts
(
    post_id serial NOT NULL,
    title character varying(200) COLLATE pg_catalog."default" NOT NULL,
    content text COLLATE pg_catalog."default" NOT NULL,
    author character varying(100) COLLATE pg_catalog."default",
    date_published timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    category character varying(50) COLLATE pg_catalog."default",
    image_url character varying(255) COLLATE pg_catalog."default",
    institution_id integer,
    CONSTRAINT blog_posts_pkey PRIMARY KEY (post_id)
);

CREATE TABLE IF NOT EXISTS public.bookmarks
(
    bookmark_id serial NOT NULL,
    user_id integer,
    institution_id integer,
    date_added timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT bookmarks_pkey PRIMARY KEY (bookmark_id),
    CONSTRAINT bookmarks_user_id_institution_id_key UNIQUE (user_id, institution_id)
);

CREATE TABLE IF NOT EXISTS public.bus_routes
(
    route_id serial NOT NULL,
    dropoff_time time without time zone,
    pickup_time time without time zone,
    pickup_location character varying(100) COLLATE pg_catalog."default",
    end_location character varying(100) COLLATE pg_catalog."default",
    start_location character varying(100) COLLATE pg_catalog."default",
    bus_fees numeric(10, 2),
    stops text COLLATE pg_catalog."default",
    route_name character varying(100) COLLATE pg_catalog."default",
    institution_id integer,
    available_seats integer,
    schedule_days character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT bus_routes_pkey PRIMARY KEY (route_id)
);

CREATE TABLE IF NOT EXISTS public.community_memberships
(
    membership_id serial NOT NULL,
    user_id integer,
    room_id integer,
    join_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT community_memberships_pkey PRIMARY KEY (membership_id),
    CONSTRAINT community_memberships_user_id_room_id_key UNIQUE (user_id, room_id)
);

CREATE TABLE IF NOT EXISTS public.community_messages
(
    message_id serial NOT NULL,
    room_id integer,
    user_id integer,
    content text COLLATE pg_catalog."default" NOT NULL,
    "timestamp" timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    is_read boolean DEFAULT false,
    CONSTRAINT community_messages_pkey PRIMARY KEY (message_id)
);

CREATE TABLE IF NOT EXISTS public.community_rooms
(
    room_id serial NOT NULL,
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    member_count integer DEFAULT 0,
    created_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    last_activity timestamp without time zone,
    CONSTRAINT community_rooms_pkey PRIMARY KEY (room_id)
);

CREATE TABLE IF NOT EXISTS public.courses
(
    course_id serial NOT NULL,
    course_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    instructor character varying(100) COLLATE pg_catalog."default",
    credits integer,
    duration character varying(50) COLLATE pg_catalog."default",
    course_description text COLLATE pg_catalog."default",
    program_id integer,
    CONSTRAINT courses_pkey PRIMARY KEY (course_id)
);

CREATE TABLE IF NOT EXISTS public.documents
(
    document_id serial NOT NULL,
    document_type character varying(50) COLLATE pg_catalog."default",
    upload_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    user_id integer,
    application_id integer,
    file_url character varying(255) COLLATE pg_catalog."default",
    file_name character varying(255) COLLATE pg_catalog."default",
    file_size integer,
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'pending'::character varying,
    CONSTRAINT documents_pkey PRIMARY KEY (document_id)
);

CREATE TABLE IF NOT EXISTS public.educational_programs
(
    program_id serial NOT NULL,
    duration character varying(50) COLLATE pg_catalog."default",
    tuition_fees numeric(10, 2),
    program_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    level character varying(50) COLLATE pg_catalog."default",
    curriculum_details text COLLATE pg_catalog."default",
    institution_id integer,
    description text COLLATE pg_catalog."default",
    start_date date,
    application_deadline date,
    requirements text COLLATE pg_catalog."default",
    capacity integer,
    CONSTRAINT educational_programs_pkey PRIMARY KEY (program_id)
);

COMMENT ON COLUMN public.educational_programs.capacity
    IS 'Maximum number of students that can be enrolled';

CREATE TABLE IF NOT EXISTS public.enrollment_applications
(
    application_id serial NOT NULL,
    application_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    status character varying(50) COLLATE pg_catalog."default",
    required_documents text COLLATE pg_catalog."default",
    user_id integer,
    program_id integer,
    CONSTRAINT enrollment_applications_pkey PRIMARY KEY (application_id)
);

CREATE TABLE IF NOT EXISTS public.faq_help_center
(
    faq_id serial NOT NULL,
    question text COLLATE pg_catalog."default" NOT NULL,
    answer text COLLATE pg_catalog."default",
    category character varying(50) COLLATE pg_catalog."default",
    date_created timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    popularity integer DEFAULT 0,
    institution_id integer,
    is_published boolean DEFAULT true,
    CONSTRAINT faq_help_center_pkey PRIMARY KEY (faq_id)
);

CREATE TABLE IF NOT EXISTS public.institution_categories
(
    category_id serial NOT NULL,
    category_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT institution_categories_pkey PRIMARY KEY (category_id),
    CONSTRAINT institution_categories_category_name_key UNIQUE (category_name)
);

CREATE TABLE IF NOT EXISTS public.institution_category_mappings
(
    mapping_id serial NOT NULL,
    institution_id integer,
    category_id integer,
    CONSTRAINT institution_category_mappings_pkey PRIMARY KEY (mapping_id),
    CONSTRAINT institution_category_mappings_institution_id_category_id_key UNIQUE (institution_id, category_id)
);

CREATE TABLE IF NOT EXISTS public.institution_facilities
(
    facility_id serial NOT NULL,
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    institution_id integer,
    CONSTRAINT institution_facilities_pkey PRIMARY KEY (facility_id)
);

CREATE TABLE IF NOT EXISTS public.institution_fees
(
    institution_fees_id serial NOT NULL,
    price numeric(10, 2),
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    institution_id integer,
    CONSTRAINT institution_fees_pkey PRIMARY KEY (institution_fees_id)
);

CREATE TABLE IF NOT EXISTS public.institution_images
(
    image_id serial NOT NULL,
    image_url text COLLATE pg_catalog."default" NOT NULL,
    is_primary boolean DEFAULT false,
    institution_id integer,
    CONSTRAINT institution_images_pkey PRIMARY KEY (image_id)
);

CREATE TABLE IF NOT EXISTS public.institutions
(
    institution_id serial NOT NULL,
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    location character varying(100) COLLATE pg_catalog."default",
    curriculum text COLLATE pg_catalog."default",
    reputation_score double precision,
    contact_info text COLLATE pg_catalog."default",
    type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    website character varying(255) COLLATE pg_catalog."default",
    contact_email character varying(100) COLLATE pg_catalog."default",
    contact_phone character varying(50) COLLATE pg_catalog."default",
    rating double precision DEFAULT 0,
    total_reviews integer DEFAULT 0,
    description text COLLATE pg_catalog."default",
    password character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT institutions_pkey PRIMARY KEY (institution_id)
);

COMMENT ON TABLE public.institutions
    IS 'Educational institutions including universities and schools';

COMMENT ON COLUMN public.institutions.rating
    IS 'Average rating from 0 to 5 based on user reviews';

CREATE TABLE IF NOT EXISTS public.interviews
(
    interview_id serial NOT NULL,
    interview_date timestamp without time zone,
    interview_price numeric(10, 2),
    application_id integer,
    CONSTRAINT interviews_pkey PRIMARY KEY (interview_id)
);

CREATE TABLE IF NOT EXISTS public.notifications
(
    notification_id serial NOT NULL,
    user_id integer,
    title character varying(100) COLLATE pg_catalog."default" NOT NULL,
    message text COLLATE pg_catalog."default" NOT NULL,
    is_read boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    type character varying(50) COLLATE pg_catalog."default",
    related_id integer,
    CONSTRAINT notifications_pkey PRIMARY KEY (notification_id)
);

CREATE TABLE IF NOT EXISTS public.password_reset_tokens
(
    reset_id serial NOT NULL,
    user_id integer,
    token character varying(255) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    expires_at timestamp without time zone NOT NULL,
    is_used boolean DEFAULT false,
    CONSTRAINT password_reset_tokens_pkey PRIMARY KEY (reset_id),
    CONSTRAINT password_reset_tokens_token_key UNIQUE (token)
);

CREATE TABLE IF NOT EXISTS public.payment_methods
(
    method_id serial NOT NULL,
    user_id integer,
    card_number character varying(19) COLLATE pg_catalog."default",
    card_holder character varying(100) COLLATE pg_catalog."default",
    expiry_date character varying(7) COLLATE pg_catalog."default",
    card_type character varying(20) COLLATE pg_catalog."default",
    is_default boolean DEFAULT false,
    last_used timestamp without time zone,
    payment_token character varying(255) COLLATE pg_catalog."default",
    provider character varying(50) COLLATE pg_catalog."default",
    encrypted_data text COLLATE pg_catalog."default",
    iv text COLLATE pg_catalog."default",
    CONSTRAINT payment_methods_pkey PRIMARY KEY (method_id)
);

CREATE TABLE IF NOT EXISTS public.payment_transactions
(
    transaction_id serial NOT NULL,
    payment_type character varying(50) COLLATE pg_catalog."default",
    amount numeric(10, 2),
    transaction_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    user_id integer,
    institution_id integer,
    CONSTRAINT payment_transactions_pkey PRIMARY KEY (transaction_id)
);

CREATE TABLE IF NOT EXISTS public.regulatory_bodies
(
    regulatory_body_id serial NOT NULL,
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    contact_info text COLLATE pg_catalog."default",
    oversight_area character varying(100) COLLATE pg_catalog."default",
    regulations text COLLATE pg_catalog."default",
    CONSTRAINT regulatory_bodies_pkey PRIMARY KEY (regulatory_body_id)
);

CREATE TABLE IF NOT EXISTS public.required_documents
(
    document_type_id serial NOT NULL,
    program_id integer,
    document_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    is_mandatory boolean DEFAULT true,
    CONSTRAINT required_documents_pkey PRIMARY KEY (document_type_id)
);

CREATE TABLE IF NOT EXISTS public.reviews
(
    review_id serial NOT NULL,
    rating integer,
    comment text COLLATE pg_catalog."default",
    review_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    user_id integer,
    institution_id integer,
    title character varying(100) COLLATE pg_catalog."default",
    CONSTRAINT reviews_pkey PRIMARY KEY (review_id)
);

CREATE TABLE IF NOT EXISTS public.scholarship_applications
(
    application_id serial NOT NULL,
    user_id integer,
    scholarship_id integer,
    application_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Pending'::character varying,
    CONSTRAINT scholarship_applications_pkey PRIMARY KEY (application_id),
    CONSTRAINT scholarship_applications_user_id_scholarship_id_key UNIQUE (user_id, scholarship_id)
);

CREATE TABLE IF NOT EXISTS public.scholarships
(
    scholarship_id serial NOT NULL,
    application_deadline date,
    scholarship_amount numeric(10, 2),
    eligibility_criteria text COLLATE pg_catalog."default",
    scholarship_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    institution_id integer,
    description text COLLATE pg_catalog."default",
    requirements text COLLATE pg_catalog."default",
    CONSTRAINT scholarships_pkey PRIMARY KEY (scholarship_id)
);

CREATE TABLE IF NOT EXISTS public.search_filters
(
    filter_id serial NOT NULL,
    filter_type character varying(50) COLLATE pg_catalog."default",
    options text COLLATE pg_catalog."default",
    CONSTRAINT search_filters_pkey PRIMARY KEY (filter_id)
);

CREATE TABLE IF NOT EXISTS public.search_history
(
    history_id serial NOT NULL,
    user_id integer,
    search_query text COLLATE pg_catalog."default" NOT NULL,
    search_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT search_history_pkey PRIMARY KEY (history_id)
);

CREATE TABLE IF NOT EXISTS public.user_settings
(
    setting_id serial NOT NULL,
    user_id integer,
    language character varying(20) COLLATE pg_catalog."default" DEFAULT 'English'::character varying,
    theme character varying(20) COLLATE pg_catalog."default" DEFAULT 'Light'::character varying,
    notification_preferences jsonb,
    CONSTRAINT user_settings_pkey PRIMARY KEY (setting_id),
    CONSTRAINT user_settings_user_id_key UNIQUE (user_id)
);

CREATE TABLE IF NOT EXISTS public.users
(
    user_id serial NOT NULL,
    email character varying(100) COLLATE pg_catalog."default" NOT NULL,
    first_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    last_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    password character varying(255) COLLATE pg_catalog."default" NOT NULL,
    national_id character varying(20) COLLATE pg_catalog."default",
    address character varying(150) COLLATE pg_catalog."default",
    gender character varying(10) COLLATE pg_catalog."default",
    join_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    profile_picture character varying(255) COLLATE pg_catalog."default",
    bio text COLLATE pg_catalog."default",
    birth_date date,
    age integer,
    CONSTRAINT users_pkey PRIMARY KEY (user_id),
    CONSTRAINT unique_email UNIQUE (email),
    CONSTRAINT unique_national_id UNIQUE (national_id)
);

CREATE TABLE IF NOT EXISTS realtime.messages
(
    topic text COLLATE pg_catalog."default" NOT NULL,
    extension text COLLATE pg_catalog."default" NOT NULL,
    payload jsonb,
    event text COLLATE pg_catalog."default",
    private boolean DEFAULT false,
    updated_at timestamp without time zone NOT NULL DEFAULT now(),
    inserted_at timestamp without time zone NOT NULL DEFAULT now(),
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    CONSTRAINT messages_pkey PRIMARY KEY (id, inserted_at)
);

ALTER TABLE IF EXISTS realtime.messages
    ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS realtime.schema_migrations
(
    version bigint NOT NULL,
    inserted_at timestamp(0) without time zone,
    CONSTRAINT schema_migrations_pkey PRIMARY KEY (version)
);

CREATE TABLE IF NOT EXISTS realtime.subscription
(
    id bigint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    subscription_id uuid NOT NULL,
    entity regclass NOT NULL,
    filters realtime.user_defined_filter[] NOT NULL DEFAULT '{}'::realtime.user_defined_filter[],
    claims jsonb NOT NULL,
    claims_role regrole NOT NULL GENERATED ALWAYS AS (realtime.to_regrole((claims ->> 'role'::text))) STORED,
    created_at timestamp without time zone NOT NULL DEFAULT timezone('utc'::text, now()),
    CONSTRAINT pk_subscription PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS storage.buckets
(
    id text COLLATE pg_catalog."default" NOT NULL,
    name text COLLATE pg_catalog."default" NOT NULL,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    public boolean DEFAULT false,
    avif_autodetection boolean DEFAULT false,
    file_size_limit bigint,
    allowed_mime_types text[] COLLATE pg_catalog."default",
    owner_id text COLLATE pg_catalog."default",
    CONSTRAINT buckets_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS storage.buckets
    ENABLE ROW LEVEL SECURITY;

COMMENT ON COLUMN storage.buckets.owner
    IS 'Field is deprecated, use owner_id instead';

CREATE TABLE IF NOT EXISTS storage.migrations
(
    id integer NOT NULL,
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    hash character varying(40) COLLATE pg_catalog."default" NOT NULL,
    executed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT migrations_pkey PRIMARY KEY (id),
    CONSTRAINT migrations_name_key UNIQUE (name)
);

ALTER TABLE IF EXISTS storage.migrations
    ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS storage.objects
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    bucket_id text COLLATE pg_catalog."default",
    name text COLLATE pg_catalog."default",
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_accessed_at timestamp with time zone DEFAULT now(),
    metadata jsonb,
    path_tokens text[] COLLATE pg_catalog."default" GENERATED ALWAYS AS (string_to_array(name, '/'::text)) STORED,
    version text COLLATE pg_catalog."default",
    owner_id text COLLATE pg_catalog."default",
    user_metadata jsonb,
    CONSTRAINT objects_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS storage.objects
    ENABLE ROW LEVEL SECURITY;

COMMENT ON COLUMN storage.objects.owner
    IS 'Field is deprecated, use owner_id instead';

CREATE TABLE IF NOT EXISTS storage.s3_multipart_uploads
(
    id text COLLATE pg_catalog."default" NOT NULL,
    in_progress_size bigint NOT NULL DEFAULT 0,
    upload_signature text COLLATE pg_catalog."default" NOT NULL,
    bucket_id text COLLATE pg_catalog."default" NOT NULL,
    key text COLLATE pg_catalog."C" NOT NULL,
    version text COLLATE pg_catalog."default" NOT NULL,
    owner_id text COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    user_metadata jsonb,
    CONSTRAINT s3_multipart_uploads_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS storage.s3_multipart_uploads
    ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS storage.s3_multipart_uploads_parts
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    upload_id text COLLATE pg_catalog."default" NOT NULL,
    size bigint NOT NULL DEFAULT 0,
    part_number integer NOT NULL,
    bucket_id text COLLATE pg_catalog."default" NOT NULL,
    key text COLLATE pg_catalog."C" NOT NULL,
    etag text COLLATE pg_catalog."default" NOT NULL,
    owner_id text COLLATE pg_catalog."default",
    version text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT s3_multipart_uploads_parts_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS storage.s3_multipart_uploads_parts
    ENABLE ROW LEVEL SECURITY;

ALTER TABLE IF EXISTS auth.identities
    ADD CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES auth.users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS identities_user_id_idx
    ON auth.identities(user_id);


ALTER TABLE IF EXISTS auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_fkey FOREIGN KEY (session_id)
    REFERENCES auth.sessions (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_auth_factor_id_fkey FOREIGN KEY (factor_id)
    REFERENCES auth.mfa_factors (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.mfa_factors
    ADD CONSTRAINT mfa_factors_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES auth.users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS mfa_factors_user_id_idx
    ON auth.mfa_factors(user_id);


ALTER TABLE IF EXISTS auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES auth.users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_session_id_fkey FOREIGN KEY (session_id)
    REFERENCES auth.sessions (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.saml_providers
    ADD CONSTRAINT saml_providers_sso_provider_id_fkey FOREIGN KEY (sso_provider_id)
    REFERENCES auth.sso_providers (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS saml_providers_sso_provider_id_idx
    ON auth.saml_providers(sso_provider_id);


ALTER TABLE IF EXISTS auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_flow_state_id_fkey FOREIGN KEY (flow_state_id)
    REFERENCES auth.flow_state (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_sso_provider_id_fkey FOREIGN KEY (sso_provider_id)
    REFERENCES auth.sso_providers (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS saml_relay_states_sso_provider_id_idx
    ON auth.saml_relay_states(sso_provider_id);


ALTER TABLE IF EXISTS auth.sessions
    ADD CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES auth.users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS sessions_user_id_idx
    ON auth.sessions(user_id);


ALTER TABLE IF EXISTS auth.sso_domains
    ADD CONSTRAINT sso_domains_sso_provider_id_fkey FOREIGN KEY (sso_provider_id)
    REFERENCES auth.sso_providers (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS sso_domains_sso_provider_id_idx
    ON auth.sso_domains(sso_provider_id);


ALTER TABLE IF EXISTS public.advisors_consultants
    ADD CONSTRAINT advisors_consultants_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.authentication_tokens
    ADD CONSTRAINT authentication_tokens_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.blog_comments
    ADD CONSTRAINT blog_comments_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES public.blog_posts (post_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.blog_comments
    ADD CONSTRAINT blog_comments_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.blog_posts
    ADD CONSTRAINT blog_posts_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.bookmarks
    ADD CONSTRAINT bookmarks_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.bookmarks
    ADD CONSTRAINT bookmarks_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.bus_routes
    ADD CONSTRAINT bus_routes_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_bus_routes_institution_id
    ON public.bus_routes(institution_id);


ALTER TABLE IF EXISTS public.community_memberships
    ADD CONSTRAINT community_memberships_room_id_fkey FOREIGN KEY (room_id)
    REFERENCES public.community_rooms (room_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.community_memberships
    ADD CONSTRAINT community_memberships_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.community_messages
    ADD CONSTRAINT community_messages_room_id_fkey FOREIGN KEY (room_id)
    REFERENCES public.community_rooms (room_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.community_messages
    ADD CONSTRAINT community_messages_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.courses
    ADD CONSTRAINT courses_program_id_fkey FOREIGN KEY (program_id)
    REFERENCES public.educational_programs (program_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.documents
    ADD CONSTRAINT documents_application_id_fkey FOREIGN KEY (application_id)
    REFERENCES public.enrollment_applications (application_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.documents
    ADD CONSTRAINT documents_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.educational_programs
    ADD CONSTRAINT educational_programs_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_programs_institution
    ON public.educational_programs(institution_id);


ALTER TABLE IF EXISTS public.enrollment_applications
    ADD CONSTRAINT enrollment_applications_program_id_fkey FOREIGN KEY (program_id)
    REFERENCES public.educational_programs (program_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.enrollment_applications
    ADD CONSTRAINT enrollment_applications_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_applications_user
    ON public.enrollment_applications(user_id);


ALTER TABLE IF EXISTS public.faq_help_center
    ADD CONSTRAINT faq_help_center_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_category_mappings
    ADD CONSTRAINT fk_institution_category_mappings_category FOREIGN KEY (category_id)
    REFERENCES public.institution_categories (category_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_category_mappings
    ADD CONSTRAINT fk_institution_category_mappings_institution FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_category_mappings
    ADD CONSTRAINT institution_category_mappings_category_id_fkey FOREIGN KEY (category_id)
    REFERENCES public.institution_categories (category_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_category_mappings
    ADD CONSTRAINT institution_category_mappings_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_facilities
    ADD CONSTRAINT fk_institution_facilities_institution FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_facilities
    ADD CONSTRAINT institution_facilities_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_fees
    ADD CONSTRAINT fk_institution_fees_institution FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_fees
    ADD CONSTRAINT institution_fees_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_images
    ADD CONSTRAINT fk_institution FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.institution_images
    ADD CONSTRAINT institution_images_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.interviews
    ADD CONSTRAINT interviews_application_id_fkey FOREIGN KEY (application_id)
    REFERENCES public.enrollment_applications (application_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.notifications
    ADD CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.password_reset_tokens
    ADD CONSTRAINT password_reset_tokens_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.payment_methods
    ADD CONSTRAINT payment_methods_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.payment_transactions
    ADD CONSTRAINT payment_transactions_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.payment_transactions
    ADD CONSTRAINT payment_transactions_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_transactions_user
    ON public.payment_transactions(user_id);


ALTER TABLE IF EXISTS public.required_documents
    ADD CONSTRAINT required_documents_program_id_fkey FOREIGN KEY (program_id)
    REFERENCES public.educational_programs (program_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.reviews
    ADD CONSTRAINT reviews_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_reviews_institution
    ON public.reviews(institution_id);


ALTER TABLE IF EXISTS public.reviews
    ADD CONSTRAINT reviews_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.scholarship_applications
    ADD CONSTRAINT scholarship_applications_scholarship_id_fkey FOREIGN KEY (scholarship_id)
    REFERENCES public.scholarships (scholarship_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.scholarship_applications
    ADD CONSTRAINT scholarship_applications_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.scholarships
    ADD CONSTRAINT scholarships_institution_id_fkey FOREIGN KEY (institution_id)
    REFERENCES public.institutions (institution_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.search_history
    ADD CONSTRAINT search_history_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.user_settings
    ADD CONSTRAINT user_settings_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS user_settings_user_id_key
    ON public.user_settings(user_id);


ALTER TABLE IF EXISTS storage.objects
    ADD CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY (bucket_id)
    REFERENCES storage.buckets (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_bucket_id_fkey FOREIGN KEY (bucket_id)
    REFERENCES storage.buckets (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_bucket_id_fkey FOREIGN KEY (bucket_id)
    REFERENCES storage.buckets (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_upload_id_fkey FOREIGN KEY (upload_id)
    REFERENCES storage.s3_multipart_uploads (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;

END;